/*
在 C 语言中，可以使用结构体（Struct） 来存放一组不同类型的数据。结构体的定义形式为：
    struct 结构体名{
        结构体所包含的变量或数组
    };
结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都
称为结构体的成员（Member） 。请看下面的一个例子：
    struct stu{
        char *name; //姓名
        int num; //学号
        int age; //年龄
        char group; //所在学习小组
        float score; //成绩
    };
stu 为结构体名，它包含了 5 个成员，分别是 name、 num、 age、 group、 score。结构体成员的定义方式与变量和
数组的定义方式相同，只是不能初始化。
注意大括号后面的分号;不能少，这是一条完整的语句。
结构体也是一种数据类型，它由程序员自己定义，可以包含多个其他类型的数据。
像 int、 float、 char 等是由 C 语言本身提供的数据类型，不能再进行分拆，我们称之为基本数据类型；而结构体可
以包含多个基本类型的数据，也可以包含其他的结构体，我们将它称为复杂数据类型或构造数据类型。
*/

/*
    结构体变量
    既然结构体是一种数据类型，那么就可以用它来定义变量。例如：
        struct stu stu1, stu2;
    定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字 struct 不能少。
    你也可以在定义结构体的同时定义结构体变量：将变量放在结构体定义的最后即可。
                struct{ //没有写 stu,类似匿名对象
                    char *name; //姓名
                    int num; //学号
                    int age; //年龄
                    char group; //所在学习小组
                    float score; //成绩
            } stu1, stu2
    这样做书写简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量。
    
*/

/*
    成员的获取和赋值
    结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获取单个元素，结构体使用
    点号.获取单个成员。获取结构体成员的一般格式为：
        结构体变量名.成员名;
    通过这种方式可以获取成员的值，也可以给成员赋值

            struct{
                char *name; //姓名
                int num; //学号
                int age; //年龄
                char group; //所在小组
                float score; //成绩
        } stu1, stu2 = { "Tom", 12, 18, 'A', 136.5 }

    不过整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值，这和数组的赋值非常类似。
    需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实
    在在的数据，需要内存空间来存储。
*/

/*
    结构体数组（带实例演示）
            struct stu{
                char *name; //姓名
                int num; //学号
                int age; //年龄
                char group; //所在小组6. float score; //成绩
        }class[5];

    结构体数组在定义的同时也可以初始化，例如：
        struct stu{
                char *name; //姓名
                int num; //学号
                int age; //年龄
                char group; //所在小组
                float score; //成绩
        }class[5] = {
            {"Li ping", 5, 18, 'C', 145.0},
            {"Zhang ping", 4, 19, 'A', 130.5},
            {"He fang", 1, 18, 'A', 148.5},
            {"Cheng ling", 2, 17, 'F', 139.0},
            {"Wang ming", 3, 17, 'B', 144.5}
        };

    结构体数组的使用也很简单，例如，获取 Wang ming 的成绩：
        class[4].score;
        修改 Li ping 的学习小组：
        class[0].group = 'B';

*/

/*
    结构体指针（指向结构体的指针）
    当一个指针变量指向结构体时，我们就称它为结构体指针。 C 语言结构体指针的定义形式一般为：
    struct 结构体名 *变量名;

    //结构体指针
    struct stu *pstu = &stu1;
*/

/*
    也可以在定义结构体的同时定义结构体指针：
        struct stu{
            char *name; //姓名
            int num; //学号
            int age; //年龄
            char group; //所在小组
            float score; //成绩
        } stu1 = { "Tom", 12, 18, 'A', 136.5 }, *pstu = &stu1;
        
    注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表
    达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&，
*/

/*
    获取结构体成员
    通过结构体指针可以获取结构体成员，一般形式为：
        (*pointer).memberName
    或者：
        pointer->memberName

    第一种写法中， .的优先级高于*， (*pointer)两边的括号不能少。如果去掉括号写作*pointer.memberName，那么就
    等效于*(pointer.memberName)，这样意义就完全不对了。
    第二种写法中， ->是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；
    这也是->在 C 语言中的唯一用途。
    上面的两种写法是等效的，我们通常采用后面的写法，这样更加直观。
*/

/*
    结构体指针作为函数参数
    结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编
    译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运
    行效率。所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。
*/

/*
    C 语言枚举类型（enum 关键字）
    枚举类型的定义形式为：
        enum typeName{ valueName1, valueName2, valueName3, ...... };
    enum 是一个新的关键字，专门用来定义枚举类型，这也是它在 C 语言中的唯一用途； typeName 是枚举类型的名
    字； valueName1, valueName2, valueName3, ......是每个值对应的名字的列表。注意最后的;不能少。
*/

/*
    我们也可以给每个名字都指定一个值：
        enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
    更为简单的方法是只给第一个名字指定值：
        enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
    这样枚举值就从 1 开始递增，跟上面的写法是等效的。
*/

/*
    C 语言共用体（union 关键字）
    通过前面的讲解，我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在 C 语
    言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union） ，它的定义格式为：
        union 共用体名{
            成员列表
        };

    结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用
    同一段内存，修改一个成员会影响其余所有成员。
    结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长
    的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把
    原来成员的值覆盖掉。 
    共用体也是一种自定义类型，可以通过它来创建变量，   
*/

/*
    C 语言位域（位段）
    在结构体定义时， 我们可以指定某个成员变量所占用的二进制位数（Bit） ， 这就是位域。
        struct bs{
            unsigned m;
            unsigned n: 4;
            unsigned char ch: 6;
        };

    成员 n、 ch 被:后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、 6 位（Bit）的内存。
    C 语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型
    限制了成员变量的最大长度， :后面的数字不能超过这个长度。
    例如上面的 bs， n 的类型是 unsigned int，长度为 4 个字节，共计 32 位，那么 n 后面的数字就不能超过 32；
    ch 的类型是 unsigned char，长度为 1 个字节，共计 8 位，那么 ch 后面的数字就不能超过 8。

    语言标准还规定，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、 signed int 和
    unsigned int（int 默认就是 signed int）；到了 C99， _Bool 也被支持了。    
*/

/*
    位域的存储
    1) 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，
    直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移
    量为类型大小的整数倍。

        #include <stdio.h>
        int main(){
            struct bs{
                unsigned m: 6;
                unsigned n: 12;
                unsigned p: 4;
            };
            printf("%d\n", sizeof(struct bs));
            return 0;
        }

    通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用&获取位
    域成员的地址是没有意义的， C 语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。    
*/

/*
    所谓位运算，就是对一个比特（Bit）位进行操作。在《数据在内存中的存储》一节中讲到，比特（Bit）是一个电子
    元器件， 8 个比特构成一个字节（Byte），它已经是粒度最小的可操作单元了。

    C 语言提供了六种位运算符：
    运算符  &      |    ^           ~   <<      >>
    说明 按位与 按位或 按位异或     取反 左移   右移

    再强调一遍， &是根据内存中的二进制位进行运算的，而不是数据的二进制形式；其他位运算符也一样。 以-9&5 为
        例， -9 的在内存中的存储和 -9 的二进制形式截然不同：
        1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111 （-9 在内存中的存储）
        -0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （-9 的二进制形式，前面多余的 0 可以抹掉）

    按位与运算通常用来对某些位清 0，或者保留某些位。
*/

/*
    按位或运算（|）
    参与|运算的两个二进制位有一个为 1 时，结果就为 1，两个都为 0 时结果才为 0。例如 1|1 为 1， 0|0 为 0， 1|0
    为 1，这和逻辑运算中的||非常类似。
    按位或运算可以用来将某些位置 1，或者保留某些位。


    例如， 9 | 5 可以转换成如下的运算：
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9 在内存中的存储）
    | 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101 （5 在内存中的存储）
    -----------------------------------------------------------------------------------
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1101 （13 在内存中的存储）
    9 | 5 的结果为 13。
*/
/*
    按位异或运算（^）
    参与^运算两个二进制位不同时，结果为 1，相同时结果为 0。例如 0^1 为 1， 0^0 为 0， 1^1 为 0。
    按位异或运算可以用来将某些二进制位反转。

    例如， 9 ^ 5 可以转换成如下的运算：
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9 在内存中的存储）
    ^ 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101 （5 在内存中的存储）
    -----------------------------------------------------------------------------------
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1100 （12 在内存中的存储）
    9 ^ 5 的结果为 12。
*/
/*
    取反运算（~）
    取反运算符~为单目运算符，右结合性，作用是对参与运算的二进制位取反。例如~1 为 0， ~0 为 1，这和逻辑运算
    中的!非常类似。。


    例如， ~9 可以转换为如下的运算：
    ~ 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9 在内存中的存储）
    -----------------------------------------------------------------------------------
    1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0110 （-10 在内存中的存储）
    所以~9 的结果为 -10。
*/
/*
    左移运算（<<）
    左移运算符<<用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。
    例如， 9<<3 可以转换为如下的运算：


    << 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9 在内存中的存储）
    -----------------------------------------------------------------------------------
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0100 1000 （72 在内存中的存储）
    所以 9<<3 的结果为 72
*/
/*
    右移运算（>>）
    右移运算符>>用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，
    那么就补 0；如果最高位是 1，那么就补 1。


    例如， 9>>3 可以转换为如下的运算：
    >> 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001 （9 在内存中的存储）
    -----------------------------------------------------------------------------------
    0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 （1 在内存中的存储）
    所以 9>>3 的结果为 1。

    又如， (-9)>>3 可以转换为如下的运算：
    >> 1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111 （-9 在内存中的存储）
    -----------------------------------------------------------------------------------
    1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 1110 （-2 在内存中的存储）
    所以(-9)>>3 的结果为 -2

    如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1）。
*/
/*
    上面的加密算法称为对称加密算法，加密和解密使用同一个密钥。
    如果加密和解密的密钥不同，则称为非对称加密算法。在非对称算法中，加密的密钥称为公钥，解密的密钥称
    为私钥，只知道公钥是无法解密的，还必须知道私钥。
    注意：程序中的 itoa() 位于 stdlib.h 头文件，它并不是一个标准的 C 函数，只有 Windows 下有，更多信息请
    猛击： C 语言 itoa()函数和 atoi()函数详解
*/