#include <stdio.h>

int main()
{
    puts("==================================================\n");
    /*
        我们将内存中字节的编号称为地址（Address） 或指针（Pointer） 。地址从 0 开始依次增加，对于 32 位环境，程
        序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。
    */
    /* int a = 100;
    char str[20] = "c.biancheng.net";
    printf("%#X, %#X\n", &a, str); */
    /*
        CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的
        地址。如果程序不小心出错，或者开发者有意为之，在 CPU 要写入数据时给它一个代码区域的地址，就会发生内
        存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。
    */
    /*
        C 指针变量的定义和使用
        数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。
        在 C 语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一
        份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。
    */
    /*
        定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：
            datatype *name;
        或者
            datatype *name = value;
        *表示这是一个指针变量， datatype 表示该指针变量所指向的数据的类型 。例如：
            int *p1;
            int a = 100;
            int *p_a = &a;
    */
    /*
        类型分别是 float*和 char*，而不是 float 和 char，它们是完全不同的数据类型
        通过指针变量取得数据
        指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：
            *pointer;
            int a = 15;
            int *p = &a;
            printf("%d, %d\n", a, *p); //两种方式都可以输出a的值
    */
    /* int a = 15;
    int *p = &a;
    //直接以十六进制输出p是a的地址值，(*p指向的是基本数据类型时)带*号是数据值
    printf("%d, %d\n", a, *p); //两种方式都可以输出a的值 */


    /*
        从运算结果可以看出： pa、 pb、 pc 每次加 1，它们的地址分别增加 4、 8、 1，正好是 int、 double、 char 类型的
        长度；减 2 时，地址分别减少 8、 16、 2，正好是 int、 double、 char 类型长度的 2 倍。
        这很奇怪，指针变量加减运算的结果跟数据类型的长度有关，而不是简单地加 1 或减 1，这是为什么呢？
    */
    /*
        警告读者不要尝试通过指针获取下一个变量的地址：
        在 VS2010 Debug 模式下的运行结果为：
            3, -858993460, -858993460, 2, -858993460, -858993460, 1, -858993460,
        可以发现，变量 a、 b、 c 并不挨着，它们中间还参杂了别的辅助数据。
    */
    /*
        我们知道，数组中的所有元素在内存中是连续排列的，如果一个指针指向了数组中的某个元素，那么加 1 就表示
        指向下一个元素，减 1 就表示指向上一个元素，这样指针的加减运算就具有了现实的意义，我们将在《C 语言数组
        指针》一节中深入探讨。
        不过 C 语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取
        决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，
        虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。
    */

    return 0;
}